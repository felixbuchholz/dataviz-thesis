<template>
  <div class="chart">
    <h5 class="sans">Current distribution of incomes</h5>
    <div v-if="tooltip.id != -1">
      <div
        v-for="(element, index) in data"
        :key="index * 10 + element.id"
        :style="
          `opacity:${tooltip.opacity};position:fixed;left:${
            tooltip.x
          }px;top:${tooltip.y + 10}px;`
        "
      >
        <div
          class="tooltip sans"
          v-if="index == tooltip.id"
          v-html="formatTooltip(element)"
        ></div>
      </div>
    </div>
    <transition name="fade">
      <svg v-if="isLoaded" :width="svgWidth" :height="svgHeight">
        <g :transform="`translate(${margin.left}, ${margin.top})`">
          <g v-for="(e, i) in data" :key="i" :id="i">
            <transition name="fade">
              <g v-if="show">
                <!-- Needs to remove elements from list -->
                <g v-for="(f, j) in e.positions" :key="`${i}${f.name}`">
                  <transition name="fade">
                    <!-- mode="in-out" -->
                    <g v-if="moe" key="moe">
                      <path
                        v-show="show"
                        fill="none"
                        :stroke="categoryColors(f.name)"
                        stroke-width="1"
                        :d="f.pathFillvalLowLimtrue"
                      />
                      <path
                        v-show="show"
                        fill="none"
                        :stroke="categoryColors(f.name)"
                        stroke-width="1"
                        opacity="0.3"
                        :d="f.pathFillvalUpLimtrue"
                      />
                      <path
                        v-show="show"
                        fill="none"
                        :stroke="categoryColors(f.name)"
                        stroke-width="0.5"
                        :d="f.pathStrokevaltrue"
                      />
                    </g>
                    <g v-else key="predict">
                      <g
                        :transform="
                          `translate(${scale.x(e.bin)},${scale.y(
                            findVerticalPosition(e.positions, j)
                          )})`
                        "
                      >
                        <!-- <rect
                          v-show="show"
                          :fill="myFill(j)"
                          :width="scale.x.bandwidth()"
                          :height="height - scale.y(f.val)"
                        /> -->

                        <path
                          v-show="show"
                          fill="none"
                          :stroke="categoryColors(j)"
                          stroke-width="0.5"
                          :d="f.path.stroke"
                        />
                        <path
                          v-show="show"
                          fill="none"
                          :stroke="categoryColors(j)"
                          stroke-width="1"
                          :d="f.path.fill"
                        />
                      </g>
                    </g>
                  </transition>
                </g>
              </g>
            </transition>
            <rect
              v-show="show"
              :key="`${i}${e.name}`"
              :x="scale.x(e.bin)"
              :y="0"
              :width="scale.x.bandwidth()"
              :height="height"
              opacity="0"
              fill="red"
              :id="e.id"
              @mousemove="mousemove"
              @mouseleave="mouseleave"
            />
          </g>
          <text
            class="graph-label"
            :transform="`translate(${width / 2}, ${height + 110})`"
            text-anchor="middle"
            fill="currentColor"
          >
            Market income per household, ranges in 2017 $
          </text>
          <g
            v-axis:x="scale"
            :transform="`translate(${0}, ${height})`"
            class="x-axis"
          ></g>
          <text
            class="graph-label"
            :transform="`rotate(-90) translate(${-height / 2},-90)`"
            text-anchor="middle"
            fill="currentColor"
          >
            Household income and benefits, in 2017 $
          </text>
          <g v-axis:y="scale" class="y-axis"></g>
        </g>
      </svg>
    </transition>
    <div>
      <h5>Temporary Interaction</h5>
      <button class="sans bold" @click="click4">scale y-axis</button>
      <button @click="click3">show/hide income</button>
      <!-- <button @click="click">fixed width</button>
      <button @click="click2">show/hide margin of error</button>
      <button @click="click5">select class</button>
      <button @click="click6">change labels on x axis</button> -->
      <!-- <input
        v-if="isLoaded"
        type="number"
        v-model.number="data[0].positions[0].val"
        v-on:input="onChange"
      /> -->
      <p class="unhug">
        <a
          class="sans"
          href="https://github.com/felixbuchholz/thesis2019/blob/master/data/thesis.pdf"
          >Layout</a
        >
      </p>
    </div>
  </div>
</template>
<script>
import * as d3 from "d3";
import { rough } from "../assets/lib/rough.js";

export default {
  name: "graphModelOne",
  props: {
    msg: String
  },
  data() {
    return {
      data: [],
      svgWidth: 400,
      svgHeight: 750,
      margin: { top: 20, left: 105, bottom: 120, right: 40 },
      tooltip: { id: null, x: 0, y: 0, opacity: 0 },
      show: false,
      mouseDown: false,
      isLoaded: false,
      moe: false,
      testSnapElim: false
    };
  },
  computed: {
    width() {
      return this.svgWidth - this.margin.left - this.margin.right;
    },
    height() {
      return this.svgHeight - this.margin.top - this.margin.bottom;
    },
    maxValue() {
      // console.log(this.data);
      const lastIndex = this.data.length - 1;
      // console.log(lastIndex);
      const lastArrayOfPositions = this.data[lastIndex].positions;
      // console.log(lastArrayOfPositions);
      // https://stackoverflow.com/questions/5732043/javascript-reduce-on-array-of-objects
      const sumOfPositionsInLastArray = lastArrayOfPositions.reduce((a, b) => {
        return { valUpLim: a.valUpLim + b.valUpLim };
      }).valUpLim;
      // console.log(sumOfPositionsInLastArray);
      return sumOfPositionsInLastArray;
    },
    scale() {
      const x = d3
        .scaleBand()
        .domain(this.data.map(x => x.bin))
        .rangeRound([0, this.width])
        .padding(0.3);
      const y = d3
        .scaleLinear()
        .domain([0, this.maxValue])
        .rangeRound([this.height, 0]);
      return { x, y };
    }
  },
  watch: {
    width() {
      // console.log("width has changed");
    },
    data: {
      deep: true,
      handler(update) {
        console.log("data has changed", update);
      }
    },
    tooltip() {
      // console.log("tooltip has changed");
    }
  },
  created() {
    this.loadData();
  },
  mounted() {
    this.onResize();
    window.addEventListener("resize", this.onResize);
    window.onmousedown = () => {
      this.mouseDown = true;
    };
    window.onmouseup = () => {
      this.mouseDown = false;
    };
  },
  methods: {
    loadData() {
      d3.json("data/test-stata.json").then(d => {
        console.log(d); // eslint-disable-line
        this.data = d;
        this.isLoaded = true;
        this.computeData();
        this.computeAllPaths();
      });
    },
    computePath(val, j) {
      // console.log(val);
      const x = 0;
      const y = 0;
      const w = this.scale.x.bandwidth();
      const h = this.height - this.scale.y(val);
      let hachureAngle = -(90 - 25);
      let hachureGap = 5;
      let fillWeight = 2;
      let fillStyle = "cross-hatch";
      if (j > 0) {
        hachureAngle = -(90 - 25);
        hachureGap = 3;
        fillWeight = 1.5;
        fillStyle = "hachure";
      }
      let generator = rough.generator();
      let rect = generator.rectangle(x, y, w, h, {
        fill: "rgba(0,0,0,1)",
        stroke: "rgba(0,0,0,1)",
        roughness: 0,
        fillWeight: fillWeight,
        hachureGap: hachureGap,
        hachureAngle: hachureAngle,
        fillStyle: fillStyle
      });
      let path = generator.toPaths(rect);
      return { stroke: path[1].d, fill: path[0].d };
    },
    computeAllPaths() {
      for (const [i, e] of this.data.entries()) {
        for (const [j, f] of e.positions.entries()) {
          // console.log(f);
          f["path"] = this.computePath(f.val, j);
        }
      }
    },
    computeData() {
      for (const e of this.data) {
        for (const f of e.positions) {
          console.log(f.val);
          f.valLowLim = f.val - f.moe;
          f.valUpLim = f.val + f.moe;
          f.total = f.val + f.moe;
        }
      }
    },
    categoryColors(j) {
      let color = "";
      if (j == 0) {
        color = "rgba(72, 72, 72, 1)";
      } else if (j >= 1) {
        color = "rgba(122, 122, 122, 1)";
      }
      // else if (j == 1) {
      //   color = "rgba(255, 138, 24, 1)";
      // } else if (j == 2) {
      //   color = "rgba(77, 175, 74, 1)";
      // } else {
      //   color = "rgba(255, 0, 0, 1)";
      // }
      return color;
    },
    mousemove(e) {
      // console.log(e);
      const i = e.target.id;
      // console.log(e) // eslint-disable-line
      // console.log(e.target.id) // eslint-disable-line
      // this.selectIndex = e.target.id;
      this.tooltip = { id: i, x: e.clientX, y: e.clientY, opacity: 1 };
      // console.log(this) // eslint-disable-line
    },
    mouseleave() {
      this.tooltip.id = -1;
    },
    formatTooltip(e) {
      // console.log(e);
      let positionshtml = "";
      for (const position of e.positions) {
        positionshtml += `<p class="tooltip-p">${
          position.longName
        }: <br /> <span class="boldest">$ ${
          position.val
        }</span>  <span class="italic"> +/- $ ${position.moe}</span></p>`;
      }
      let tooltiphtml = `<p class="graph-label">Income range:<br /> <span class="">${
        e.bin
      } $</span></p>${positionshtml}`;
      return tooltiphtml;
    },
    click() {
      this.$el.style = "width: 300px";
      this.onResize();
    },
    click2() {
      // this.show = false;
      // setTimeout(() => {
      //   this.show = true;
      // }, 100);
      if (this.moe) {
        this.moe = false;
      } else {
        this.moe = true;
      }
    },
    click3() {
      if (!this.testSnapElim) {
        this.testSnapElim = true;
        for (const e of this.data) {
          // console.log(e.positions[1]);
          e.positions[1]["valueBefore"] = e.positions[0]["val"];
          e.positions[1]["moeBefore"] = e.positions[0]["moe"];
          e.positions[1]["val"] = 0;
          e.positions[1]["moe"] = 0;
        }
      } else {
        this.testSnapElim = false;
        for (const e of this.data) {
          e.positions[1]["val"] = e.positions[0]["valueBefore"];
          e.positions[1]["moe"] = e.positions[0]["moeBefore"];
        }
      }
      this.computeAllPaths();
      this.computeData();
      this.show = false;
      setTimeout(() => {
        if (this.mouseDown == false) {
          this.show = true;
        }
      }, 100);
    },
    click4() {
      setTimeout(() => {
        window.scrollBy({
          top: 2700,
          left: 0,
          behavior: "smooth"
        });
      }, 800);
      console.log("outside");
      this.svgHeight = 3000;
      this.computeAllPaths();
    },
    click5() {
      [].map.call(this.$el.querySelectorAll(".benefits"), function(e) {
        e.classList.toggle("benefits--active");
      });
      // console.log(this.$el.querySelectorAll(".benefits"));
      // this.$el.querySelectorAll(".benefits").toggle
    },
    click6() {
      [].map.call(this.$el.querySelectorAll(".x-axis .tick"), (e, i) => {
        e.querySelector("line").setAttribute("y2", i % 2 == 0 ? 6 : 10);
        console.log(e.innerHTML);
        e.querySelector("text").setAttribute("y", i % 2 == 0 ? 9 : 20);
        // if (i % 2 != 0) {
        //   e.setAttribute("y2", 10);
        // }
        // e.classList.toggle("benefits--active");
      });
      // console.log(this.$el.querySelectorAll(".benefits"));
      // this.$el.querySelectorAll(".benefits").toggle
    },
    wrap(text, width) {
      text.each(function() {
        var text = d3.select(this),
          words = text
            .text()
            .split(/\s+/)
            .reverse(),
          word,
          line = [],
          lineNumber = 0,
          lineHeight = 1.1, // ems
          y = text.attr("y"),
          dy = parseFloat(text.attr("dy")),
          tspan = text
            .text(null)
            .append("tspan")
            .attr("x", 0)
            .attr("y", y)
            .attr("dy", dy + "em");
        while ((word = words.pop())) {
          line.push(word);
          tspan.text(line.join(" "));
          if (tspan.node().getComputedTextLength() > width) {
            line.pop();
            tspan.text(line.join(" "));
            line = [word];
            tspan = text
              .append("tspan")
              .attr("x", 0)
              .attr("y", y)
              .attr("dy", ++lineNumber * lineHeight + dy + "em")
              .text(word);
          }
        }
      });
    },
    onResize(event) {
      console.log("window has been resized", event, this);
      this.svgWidth = this.$el.getBoundingClientRect().width;
      this.show = false;
      setTimeout(() => {
        if (this.mouseDown == false) {
          this.computeAllPaths();
          this.show = true;
        }
      }, 800);
      // this.$el.querySelector(".rough").style("opacity", 0);
    },
    onChange(event) {
      // console.log("changed", event);
      this.computeData();
      this.computeAllPaths();
    },
    findVerticalPosition(array, index) {
      // console.log("fvp");
      let sum = 0;
      let arrayUpToPosition = array.slice(0, index + 1);
      for (var i = 0; i < arrayUpToPosition.length; i++) {
        // console.log(
        //   i,
        //   arrayUpToPosition[i]["total"],
        //   arrayUpToPosition[i]["val"]
        // );
        sum += arrayUpToPosition[i]["total"];
        // if (i == arrayUpToPosition.length - 1) {
        //   sum += 0;
        // }
      }
      return sum;
    },
    myFill(j) {
      if (j == 0) {
        return "rgba(0,0,0,0.5)";
      } else {
        return "rgba(0,0,0,0.3)";
      }
    },
    findVerticalEnding(array, index, property, moe) {
      var arrayUpToPosition = array.slice(0, index + 1);
      // console.log(array, array[index].name, array[index].val, property);
      let sum = 0;
      if (moe) {
        if (property == "valLowLim") {
          for (var i = 0; i < arrayUpToPosition.length; i++) {
            // console.log(i);
            sum += arrayUpToPosition[i]["valUpLim"];
            if (i == arrayUpToPosition.length - 1) {
              sum -= 2 * arrayUpToPosition[i].moe;
            }
          }
        } else if (property == "valUpLim") {
          for (var i = 0; i < arrayUpToPosition.length; i++) {
            sum += arrayUpToPosition[i]["valUpLim"];
          }
        } else if (property == "val") {
          for (var i = 0; i < arrayUpToPosition.length; i++) {
            // console.log(i);
            sum += arrayUpToPosition[i]["valUpLim"];
            if (i == arrayUpToPosition.length - 1) {
              sum -= 1 * arrayUpToPosition[i].moe;
            }
          }
        }
      } else {
        for (var i = 0; i < arrayUpToPosition.length; i++) {
          // console.log(arrayAtPosition[i].val);
          sum += arrayUpToPosition[i].val;
        }
      }
      return sum;
    }
  },
  directives: {
    axis(el, binding) {
      const axis = binding.arg; // x or y
      const axisMethod = { x: "axisBottom", y: "axisLeft" }[axis];
      const methodArg = binding.value[axis];
      // d3.axisBottom(scale.x)
      if (binding.arg == "y") {
        d3.select(el)
          .call(
            d3[axisMethod](methodArg)
              .tickFormat(d3.format(",d"))
              .ticks(15)
          )
          .selectAll(".tick text")
          .attr("transform", "rotate(-25)")
          .attr("text-anchor", "end");
      } else {
        let self = this;
        // console.log(el);
        d3.select(el)
          .call(d3[axisMethod](methodArg).tickFormat(d3.format("c")))
          .selectAll(".tick text")
          .attr("transform", "rotate(-25) translate(-2,4)")
          .attr("text-anchor", "end")
          .attr("alignment-baseline", "after-edge");
      }
    }
  },
  beforeDestroy() {
    // Unregister the event listener before destroying this Vue instance
    window.removeEventListener("resize", this.onResize);
  }
};
</script>
<style scoped lang="scss"></style>
